import { generateUUID } from '../utils/random';

const store = [];
const subscribes = {};
const forceSubscribes = [];
let middlewares = [];
let reducers = () => {};

const replaceArrayProp = str => str.replace(/\[([0-9]+)\]/g, '.$1');

const getLastState = () => {
  return store[store.length - 1]
};

const getOffsetState = (offset) => {
  return store[store.length - 1 - offset];
};

const getDataByKey = (key, state) => {
  if (!state) {
    return undefined;
  }
  const keys = replaceArrayProp(key.replace(/^state\./, '')).split('.');
  let result = state;
  for (let i = 0, ln = keys.length; i < ln; i += 1) {
    result = result[keys[i]];
    if (result === undefined) {
      return result;
    }
  }
  return result;
};

const addNewState = (action = {}) => {
  store.push(reducers({}, action));
};

const update = () => {
  const state = getLastState();
  const prevState = getOffsetState(1);
  Object.keys(subscribes).forEach((key) => {
    const currentValue = getDataByKey(key, state);
    const prevValue = getDataByKey(key, prevState);
    if (currentValue !== prevValue) {
      subscribes[key].forEach(subscribe => subscribe.callback());
    }
  });
  forceSubscribes.forEach(forceSubscribe => forceSubscribe.callback());
};

const combineReducers = (initReducers) => {
  reducers = (tempState = {}, action = {}) => {
    const newState = {};
    const state = getLastState();
    Object.keys(initReducers).forEach((reducer) => {
      newState[reducer] = initReducers[reducer](state ? state[reducer] : state, action);
    });
    return newState;
  };
  return reducers;
};

const dispatch = (action) => {
  if (typeof action === 'function') {
    action(dispatch, getLastState);
  } else {
    const skipMiddlewares = action.skipMiddlewares;
    if (!skipMiddlewares) {
      middlewares.forEach((middleware, index) => {
        const nextMiddleware = middlewares[index + 1]
          || ((action) => {
              dispatch({ ...action, skipMiddlewares: true })
            });
        middleware(nextMiddleware)(action);
      });
    }
    if (!middlewares.length || skipMiddlewares) {
      addNewState(action);
      update();
    }
  }
};

const bindActionCreators = (actionCreators, localDispatch = dispatch) => {
  const boundActionCreators = {};
  Object.keys(actionCreators).forEach((key) => {
    boundActionCreators[key] = args => localDispatch(actionCreators[key](args));
  });
  return boundActionCreators;
};

const subscribe = (...params) => {
  let id, cb, keys;
  if (typeof params[0] !== 'function') {
    id = params[0];
    cb = params[1] || (() => {});
    keys = params[2];
  } else {
    id = generateUUID();
    cb = params[0];
    keys = params[1];
  }
  return keys ? keysSubscribe(id, keys, cb) : forceSubscribe(id, cb);
};

const unsubscribe = (id, keys) => {
  return keys && keys.length ? keysUnsubscribe(id, keys) : forceUnsubscribe(id);
};

const keysSubscribe = (id, keys, callback) => {
  keys.map(replaceArrayProp).forEach((key) => {
    const keySubscribes = subscribes[key];
    if (keySubscribes) {
      keySubscribes.push({ id, callback });
    } else {
      subscribes[key] = [{ id, callback }];
    }
  });
  return () => keysUnsubscribe(id, keys);
};

const keysUnsubscribe = (id, keys = []) => {
  keys.map(replaceArrayProp).forEach((key) => {
    const keySubscribes = subscribes[key];
    if (keySubscribes) {
      for (let i = 0, ln = keySubscribes.length; i < ln; i += 1) {
        if (keySubscribes[i].id === id) {
          keySubscribes.splice(i, 1);
          if (!keySubscribes.length) {
            delete subscribes[key];
          }
          break;
        }
      }
    }
  });
};

const forceSubscribe = (id, callback) => {
  if (!forceSubscribes.find(s => s.id === id)) {
    forceSubscribes.push({ id, callback });
  }
  return () => forceUnsubscribe(id);
};

const forceUnsubscribe = (id) => {
  for (let i = 0, ln = forceSubscribes.length; i < ln; i += 1) {
    if (forceSubscribes[i].id === id) {
      forceSubscribes.splice(i, 1);
      break;
    }
  }
};

const applyMiddleware = (...middlewares) => {
  return function (createStore) {
    return function (localReducer, preloadedState, enhancer) {
      const store = createStore(localReducer, preloadedState, enhancer);
      let _dispatch = store.dispatch;
      let chain = [];
      const middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch(action) {
          return _dispatch(action);
        }
      };
      chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(undefined, chain)(store.dispatch);
      return Object.assign({}, store, {
        dispatch: _dispatch
      });
    };
  };
};

const createStore = (rootReducer, secondParam, thirdParam) => {
  const enhancer = typeof secondParam === 'function' ? secondParam : thirdParam;
  const state = typeof secondParam === 'object' ? secondParam : {};
  if (enhancer && typeof enhancer === "function") {
    const newCreateStore = enhancer(createStore);
    return enhancer(createStore)(rootReducer, state);
  }
  addNewState();
  return {
    dispatch,
    subscribe,
    getState: getLastState,
    replaceReducer: (newReducers) => {
      reducers = newReducers;
      addNewState({});
    },
  };
};

function compose() {
  const ln = arguments.length;
  const funcs = new Array(ln);
  for (let i = 0; i < ln; i += 1) {
    funcs[i] = arguments[i];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  const last = funcs[funcs.length - 1];
  const rest = funcs.slice(0, -1);
  return () => {
    return rest.reduceRight((composed, f) => {
      return f(composed);
    }, last.apply(undefined, arguments));
  };
}

export {
  bindActionCreators,
  replaceArrayProp,
  getLastState,
  getDataByKey,
  combineReducers,
  dispatch,
  subscribe,
  unsubscribe,
  applyMiddleware,
  createStore,
  compose,
}